/* -*- tab-width: 4; -*- */
/*
 * Copyright Â© 2017-2018, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU Lesser General Public License,
 * version 2.1, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 */

module libnetinet {

import from libtypes all;

type octetstring eth_addr_t length(6);
type octetstring in6_addr_t length(16);

type enumerated ipproto_t {
	IPPROTO_IP(0),
	IPPROTO_ICMP(1),
	IPPROTO_TCP(6),
	IPPROTO_UDP(17),
	IPPROTO_IPV6(41),
	IPPROTO_ICMPv6(58),
	IPPROTO_RAW(255)
} with {
	variant "FIELDLENGTH(8)";
};

type enumerated ethertype_t {
	ETHERTYPE_IP('0800'H),
	ETHERTYPE_ARP('0806'H),
	ETHERTYPE_VLAN('8100'H),
	ETHERTYPE_IPV6('86dd'H)
} with {
	variant "FIELDLENGTH(16)";
};

type enumerated icmp6_type_t {
	ICMP6_ECHO_REQUEST(128),
	ICMP6_ECHO_REPLY(129),
	ICMP6_ROUTER_SOLICIT(133),
	ICMP6_ROUTER_ADVERT(134),
	ICMP6_NEIGHBOR_SOLICIT(135),
	ICMP6_NEIGHBOR_ADVERT(136)
}

type record eth_t {
	ethhdr_t	hdr,
	vlan_tag_t	vlan optional,
	eth_data_t	data optional
} with {
	variant "CROSSTAG(vlan, hdr.h_proto = ETHERTYPE_VLAN)";
	variant(data) "CROSSTAG(
		ip6, hdr.h_proto	= ETHERTYPE_IPV6;
		ip6, vlan.vlan_type	= ETHERTYPE_IPV6;
	)";
}

type record ethhdr_t {
	eth_addr_t	h_dest,
	eth_addr_t	h_source,
	ethertype_t h_proto
} with {
	variant(h_proto) "BYTEORDER(last)";
}

type union eth_data_t {
	ip6_t		ip6,
	octetstring	data
}

type record vlan_tag_t {
	bit3_t		vlan_pri,
	bit1_t		vlan_cfi,
	integer		vlan_id,
	ethertype_t vlan_type
} with {
	variant(vlan_id) "FIELDLENGTH(12),BYTEORDER(last)";
	variant(vlan_type) "BYTEORDER(last)";
}

type record ip6_t {
	ip6_hdr_t	hdr,
	ip6_data_t	data optional
} with {
	variant(data) "CROSSTAG(
		icmp6,	hdr.ip6_nxt = IPPROTO_ICMPv6;
		tcp,	hdr.ip6_nxt = IPPROTO_TCP;
		udp,	hdr.ip6_nxt = IPPROTO_UDP;
	)";
	variant (hdr) "LENGTHTO(data)";
	variant (hdr) "LENGTHINDEX(ip6_plen)";
}

type record ip6_hdr_t {
	uint32_t	ip6_vfc,
	uint16_t	ip6_plen,
	ipproto_t	ip6_nxt,
	uint8_t		ip6_hlim,
	in6_addr_t	ip6_src,
	in6_addr_t	ip6_dst
} with {
	variant(ip6_plen) "BYTEORDER(last)";
}

type union ip6_data_t {
	icmp6_t icmp6,
	tcp_t tcp,
	udp_t udp,
	octetstring	data
}

type record icmp6_t {
	icmp6_hdr_t		hdr,
	icmp6_data_t	data
} with {
	variant(data) "CROSSTAG(
		echo, hdr.icmp6_type = ICMP6_ECHO_REQUEST;
		echo, hdr.icmp6_type = ICMP6_ECHO_REPLY;
	)";
}

type record icmp6_hdr_t {
	icmp6_type_t	icmp6_type,
	uint8_t			icmp6_code,
	uint16_t		icmp6_cksum
}

type union icmp6_data_t {
	icmp6_echo_t	echo,
	octetstring		data
}

type record icmp6_echo_t {
	uint16_t	id,
	uint16_t	seq,
	octetstring	data optional
}

type record th_flags_t {
	bit4_t doff,
	bit3_t res,
	bit3_t ecn,
	bit1_t urg,
	bit1_t ack,
	bit1_t psh,
	bit1_t rst,
	bit1_t syn,
	bit1_t fin
}

type record tcphdr_t {
	uint16_t	th_sport,
	uint16_t	th_dport,
	uint32_t	th_seq,
	uint32_t	th_ack,
	th_flags_t	th_flags,
	uint16_t	th_win,
	uint16_t	th_sum,
	uint16_t	th_urp
} with {
	variant(th_sport, th_dport, th_seq, th_ack, th_win) "BYTEORDER(last)";
}

type record tcp_t {
	tcphdr_t hdr,
	octetstring data optional
}

type record udphdr_t {
	uint16_t uh_sport,
	uint16_t uh_dport,
	uint16_t uh_ulen,
	uint16_t uh_sum
} with {
	variant(uh_sport, uh_dport, uh_ulen) "BYTEORDER(last)";
}

type record udp_t {
	udphdr_t hdr,
	octetstring data optional
} with {
	variant (hdr) "LENGTHTO(data,hdr)";
	variant (hdr) "LENGTHINDEX(uh_ulen)";
}

external function eth_enc(in eth_t packet) return octetstring
	with { extension "prototype(convert) encode(RAW)" };

external function eth_dec(in octetstring data) return eth_t
	with { extension "prototype(convert) decode(RAW)" };

} with {
	variant "";
	variant "FIELDORDER(msb)";
	encode "RAW";
}
