/*
 * Copyright Â© 2017-2018, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU Lesser General Public License,
 * version 2.1, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 */

module tcp_suite {

	import from libtypes all;
	import from libtest all;
	import from libtcp all;
	import from libutils_module all;

	/**
	 * All TCP flags are zero
	 */
	testcase Test_TCP_001(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		tcp_send();

		tcp_recv(on_timeout := pass);
	}

	/**
	 * All TCP flags are one
	 */
	testcase Test_TCP_002(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.urg);
		bit_set(f.ack);
		bit_set(f.psh);
		bit_set(f.rst);
		bit_set(f.syn);
		bit_set(f.fin);

		tcp_send();

		tcp_recv(on_timeout := pass);
	}

	/**
	 * SYN sent, expect SYN+ACK
	 */
	testcase Test_TCP_003(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.syn);

		tcp_send();

		tcp_recv();

		if (bit_is_set(f.syn) and bit_is_set(f.ack)) {
			sv(pass);
		}

		tcp_close();
	}

	/**
	 * SYN sent, got SYN+ACK, send ACK with no sequence numbers
	 */
	testcase Test_TCP_004(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.syn);

		tcp_send();

		tcp_recv();

		if (bit_is_set(f.syn) and bit_is_set(f.ack)) {
			sv(pass);
		}

		tcp_init(reset_state := true);

		bit_set(f.ack);

		tcp_send();

		tcp_recv();

		if (bit_is_set(f.rst)) {
			sv(pass);
		}

		tcp_close();
	}

	/**
	 * SYN sent, expecting SYN+ACK, send ACK, increment sequence numbers
	 */
	testcase Test_TCP_005(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.syn);

		tcp_send();

		tcp_recv();

		if (bit_is_set(f.syn) and bit_is_set(f.ack)) {
			sv(pass);
		}

		tcp_init();

		bit_set(f.ack);

		tcp_send();

		tcp_recv(on_timeout := pass);

		tcp_close();
	}

	/**
	 * Send SYN with RST
	 */
	testcase Test_TCP_006(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.syn);
		bit_set(f.rst);

		tcp_send();

		tcp_recv();

		if (bit_is_set(f.ack)) {
			sv(pass);
		}

		tcp_close();
	}

	/**
	 * Send RST in the middle of three way handshake
	 */
	testcase Test_TCP_007(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.syn);

		tcp_send();

		tcp_recv();

		if (bit_is_set(f.syn) and bit_is_set(f.ack)) {
			sv(pass);
		}

		tcp_init();

		bit_set(f.rst);

		tcp_send();

		tcp_recv();

		if (bit_is_set(f.ack)) {
			sv(pass);
		}

		tcp_close();
	}

	/**
	 * Send SYN instead of ACK
	 */
	testcase Test_TCP_008(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.syn);

		tcp_send();

		tcp_recv();

		if (bit_is_set(f.syn) and bit_is_set(f.ack)) {
			sv(pass);
		}

		tcp_init();

		bit_set(f.syn);

		tcp_send();

		tcp_recv();

		if (bit_is_set(f.rst)) {
			sv(pass);
		}

		tcp_close();
	}

	/**
	 * Send SYN+ACK, expect nothing
	 */
	testcase Test_TCP_009(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.syn);
		bit_set(f.ack);

		tcp_send();

		tcp_recv(on_timeout := pass);
	}

	/**
	 * Test closing a connection
	 */
	testcase Test_TCP_010(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		tcp_connect();

		bit_set(f.fin);

		tcp_send();

		tcp_recv();

		if (bit_is_set(f.ack)) {
			sv(pass);
		}

		tcp_close()
	}

	/**
	 * SYN sent with the wrong checksum
	 */
	testcase Test_TCP_011(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.syn);

		tcp.hdr.th_sum := 1;

		tcp_send();

		tcp_recv(on_timeout := pass);
	}

	/**
	 * SYN sent, expecting SYN+ACK, verify TCP checksum
	 */
	testcase Test_TCP_012(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.syn);

		tcp_send();

		tcp_recv();

		if (tcp.hdr.th_sum == fx_inet6_chksum(data)) {
			sv(pass);
		} else {
			sv(fail);
		}

		tcp_close();
	}

	/**
	 * Check the reaction on SYN with payload
	 */
	testcase Test_TCP_013(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		bit_set(f.syn);

		tcp_send('0123'O);

		tcp_recv();

		if (bit_is_set(f.ack)) {
			sv(pass);
		}

		if (bit_is_set(f.syn)) {
			sv(fail);
		}

		tcp_close();
	}

	/**
	 * Establish a connection, send data
	 */
	testcase Test_TCP_014(inout cf_t cf) runs on tcp_node {

		tcp_node_init(cf);

		tcp_connect();

		bit_set(f.psh);

		th_seq := th_seq - 1;

		tcp_send('0123'O);

		tcp_recv();

		if (bit_is_set(f.ack)) {
			sv(pass);
		}

		tcp_close();
	}

	control {
		var cf_t cf;
		execute(Test_TCP_001(cf));
		execute(Test_TCP_002(cf));
		execute(Test_TCP_003(cf));
		execute(Test_TCP_004(cf));
		execute(Test_TCP_005(cf));
		execute(Test_TCP_006(cf));
		execute(Test_TCP_007(cf));
		execute(Test_TCP_008(cf));
		execute(Test_TCP_009(cf));
		execute(Test_TCP_010(cf));
		execute(Test_TCP_011(cf));
		execute(Test_TCP_012(cf));
		execute(Test_TCP_013(cf));
		execute(Test_TCP_014(cf));
	}

} with { encode "RAW" }
