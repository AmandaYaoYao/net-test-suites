/* -*- tab-width: 4; -*- */
/*
 * Copyright Â© 2018, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU Lesser General Public License,
 * version 2.1, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 */

/*
 * This is a sanity check for experimental TCP implementation for Zephyr RTOS:
 * https://github.com/ozhuraki/zephyr/blob/tcp2-dev/subsys/net/ip/tcp2.c
 *
 * It is also an exploratory playground for bringing improvements
 * to tcp_suite.ttcn (which aims to be abstract from the system under test).
 *
 */

module tcp2_check {

import from libtypes all;
import from libnetinet all;
import from libtest all;
import from libutils all;
import from port_data_types all;

modulepar {
	float T_default := 0.1;
}

type bitstring event_t length(3);

const event_t EV_NONE			:='000'B;
const event_t EV_KEEP			:='111'B;
const event_t EV_TIMEOUT		:='001'B;
const event_t EV_UNEXPECTED_MSG :='010'B;

type component tcp_ct extends test_CT {
	var tcp_t tcp;
	var tcp_state_t s := TCP_NONE;
	var integer msn := 0; /* my sequence number */
	var integer psn := 0; /* peer sequence number */
	timer T := T_default;
	var event_t events := EV_NONE;
	var default d_as_timeout;
	var default d_as_unexpected_msg;
}

altstep as_timeout() runs on tcp_ct
{
	[] T.timeout { setverdict(fail); stop; }
}

altstep as_unexpected_msg() runs on tcp_ct
{
	[] P_TCP.receive(?) { setverdict(fail); stop; }
}

function fail_on_event(event_t event) runs on tcp_ct
{
	if (event == EV_KEEP) {
		return;
	}

	if ((event and4b EV_TIMEOUT) == EV_TIMEOUT) {
		d_as_timeout := activate(as_timeout());
		events := events or4b EV_TIMEOUT;
	} else {
		deactivate(d_as_timeout);
		events := events and4b (not4b EV_TIMEOUT);
	}

	if ((event and4b EV_UNEXPECTED_MSG) == EV_UNEXPECTED_MSG) {
		d_as_unexpected_msg := activate(as_unexpected_msg());
		events := events or4b EV_UNEXPECTED_MSG;
	} else {
		deactivate(d_as_unexpected_msg);
		events := events and4b (not4b EV_UNEXPECTED_MSG);
	}
}

function st(tcp_state_t new, event_t fail_on := EV_KEEP) runs on tcp_ct
{
	log(f_tcp_state_to_string(s), " -> ", f_tcp_state_to_string(new));
	s := new;
	fail_on_event(fail_on);
}

type record tcp_json {
	charstring state
} with {
	encode "JSON";
	variant(state) "JSON: name as state";
}

external function f_json_enc(in tcp_json x) return octetstring
	with { extension "prototype(convert) encode(JSON)" }

external function f_json_dec(in octetstring x) return tcp_json
	with { extension "prototype(convert) decode(JSON)" }

/**
 * Test active TCP connection establishment,
 * data transfer (data echoing expected) and active close
 */
testcase tc_tcp_conn(octetstring d := ''O) runs on tcp_ct
{
	test_ct_init();

	var octetstring data_to_send := d;
	var octetstring data_unack := ''O;
	var integer data_step := 1;

	P_TCP.send(ts_TCP(f := TH_SYN, sn := post_inc(msn)));
	st(TCP_SYN_SENT, fail_on := EV_TIMEOUT or4b EV_UNEXPECTED_MSG);
	T.start;

	alt {
	[s == TCP_SYN_SENT] P_TCP.receive(tr_TCP(f := TH_SYN or4b TH_ACK,
											 an := msn)) -> value tcp {
		T.stop;
		psn := tcp.th_seq;
		st(TCP_SYN_RECEIVED);
		P_TCP.send(ts_TCP(f := TH_ACK, sn := msn, an := pre_inc(psn)));
		st(TCP_ESTABLISHED, fail_on := EV_NONE);
		T.start; repeat;
	}
	[s == TCP_ESTABLISHED] P_TCP.receive(tr_TCP) -> value tcp {
		T.stop;
		var tcp_t tcp2 := valueof(ts_TCP);
		if (th_is_set(tcp, TH_PSH)) {
			th_set(tcp2, TH_ACK);
			pre_inc(psn, lengthof(tcp.data));
		}
		if (th_is_set(tcp, TH_ACK)) {
			if (tcp.th_ack > msn - lengthof(data_unack)) {
				var integer diff := tcp.th_ack - (msn - lengthof(data_unack));
				data_pop(data_unack, diff);
			}
		}
		if (tcp2.th_flags != TH_NONE) {
			tcp2.th_seq := msn;
			tcp2.th_ack := psn;
			P_TCP.send(tcp2);
		}
		T.start; repeat;
	}
	[s == TCP_ESTABLISHED] T.timeout {
		if (lengthof(data_unack) > 0) { goto wait_for_data; }
		if (lengthof(data_to_send) > 0) {
			data_unack := data_pop(data_to_send, data_step);
			P_TCP.send(ts_TCP(f := TH_PSH,
							  sn := post_inc(msn, lengthof(data_unack)),
							  an := psn, d := data_unack));
			goto wait_for_data;
		}
		/* Everything is sent and aknowledged, do active close */
		st(TCP_FIN_WAIT1, fail_on := EV_TIMEOUT or4b EV_UNEXPECTED_MSG);
		P_TCP.send(ts_TCP(f := TH_FIN or4b TH_ACK, sn := post_inc(msn),
						  an := psn));
label wait_for_data;
		T.start; repeat;
	}
	[s == TCP_FIN_WAIT1] P_TCP.receive(tr_TCP(f := TH_ACK)) {
		T.stop;
		st(TCP_FIN_WAIT2);
		T.start; repeat;
	}
	[s == TCP_FIN_WAIT2] P_TCP.receive(tr_TCP(f := TH_FIN or4b TH_ACK)) {
		T.stop;
		P_TCP.send(ts_TCP(f := TH_ACK, sn := msn, an := pre_inc(psn)));
		st(TCP_TIME_WAIT, fail_on := EV_NONE);
		T.start; repeat; /* T * 2 */
	}
	[s == TCP_TIME_WAIT] T.timeout {
		st(TCP_CLOSED);
	}
	}

	var tcp_state_t peer_target_state := TCP_CLOSED;
	var udp_t udp;
	var tcp_json json;

	P_UDP.send(ts_UDP);
	T.start;

	alt {
		[] P_UDP.receive(?) -> value udp {
			T.stop;
			json := f_json_dec(udp.data);
		}
		[] T.timeout {
			setverdict(fail);
		}
	}

	if (s == TCP_CLOSED and
			lengthof(data_to_send) == 0 and
			lengthof(data_unack) == 0 and
			json.state == f_tcp_state_to_string(peer_target_state)) {
		setverdict(pass);
	}
}

control {
	execute(tc_tcp_conn(d := '01'O));
}

}
