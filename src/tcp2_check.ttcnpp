/* -*- c-basic-offset: 4; tab-width: 4; -*- */
/*
 * Copyright Â© 2018-2019, Intel Corporation.
 *
 * SPDX-License-Identifier: LGPL-2.1-only
 */

/*
 * This is a sanity check for experimental TCP for Zephyr OS:
 * https://github.com/ozhuraki/zephyr/blob/tcp2-dev/README.md
 */

#include "tcp2_check.ttcnin"

module tcp2_check {

import from libtypes all;
import from libnetinet all;
import from libtest all;
import from libutils all;

import from tcp2_utils all;

modulepar {
	boolean peer_assert_enabled := true; /* TODO rename to tp_enabled */
	float T_peer_default := -1.0; /* default peer's retransmission timeout,
									 sec (optional, negative value: unused) */
}

type component tcp_ct extends test_CT {
	var tcp_state_t s := TCP_LISTEN;
	var u32 seq := 0;
	var u32 ack := 0;
	var octetstring snd := ''O;
	var fuzzer_ct ct_fuzzer;
	port port_cf P_FZ;
	var tcp_t tcp; /* TODO: Drop */
}

function st(tcp_state_t new, event_t fail_on := EV_KEEP) runs on tcp_ct
{
	//log(tcp_state_to_string(s), " -> ", tcp_state_to_string(new));
	s := new;
	fail_on_events(fail_on);
}

/**
 * Peer's active connection establishment, data transfer
 * (data echoing expected) and suite's active close
 */
function tcp_connect(octetstring data_to_send := ''O,
						  octetstring data_to_receive := ''O,
								boolean close := true,
								integer isn := 0) runs on tcp_ct
{
	var octetstring data := ''O;
	var octetstring data_received := ''O;

	seq := isn;

	tcp_init();

	data_push(data, data_to_send);

	TT.start;

	P_TCP.send(ts_TCP(f := TH_SYN, th_seq := u32_post_inc(seq)));
	st(TCP_SYN_SENT, fail_on := EV_TIMEOUT or4b EV_UNEXPECTED_MSG);
	T.start;

	alt {
	[s == TCP_SYN_SENT] P_TCP.receive(tr_TCP(f := TH_SYN or4b TH_ACK,
											 th_ack := seq)) -> value tcp {
		T.stop;
		peer_assert(TCP_SYN_SENT);
		st(TCP_SYN_RECEIVED);
		ack := tcp.th_seq;
		P_TCP.send(ts_TCP(f := TH_ACK, th_seq := seq, th_ack := u32_pre_inc(ack)));
		st(TCP_ESTABLISHED, fail_on := EV_NONE);
		if (close == false) {
			goto end;
		}
		T.start; repeat;
	}

	[s == TCP_ESTABLISHED] P_TCP.receive(tr_TCP) -> value tcp {
		T.stop;
		peer_assert(TCP_ESTABLISHED);
		var tcp_t tcp2 := valueof(ts_TCP);
		if (th_is_set(tcp, TH_PSH)) {
			data_push(data_received, tcp.data);
			th_set(tcp2, TH_ACK);
			u32_pre_inc(ack, lengthof(tcp.data));
		}
		if (th_is_set(tcp, TH_ACK)) {
			if (tcp.th_ack > seq - lengthof(snd)) {
				var integer diff := tcp.th_ack - (seq - lengthof(snd));
				data_pop(snd, diff);
			}
		}
		if (tcp2.th_flags != TH_NONE) {
			tcp2.th_seq := seq;
			tcp2.th_ack := ack;
			P_TCP.send(tcp2);
		}
		T.start; repeat;
	}
	[s == TCP_ESTABLISHED] T.timeout {
		peer_assert(TCP_ESTABLISHED);
		if (lengthof(snd) > 0) { goto wait_for_data; }
		if (lengthof(data_to_send) > 0) {
			snd := data_pop(data_to_send);
			P_TCP.send(ts_TCP(f := TH_PSH,
							  th_seq := u32_post_inc(seq, lengthof(snd)),
							  d := snd));
			goto wait_for_data;
		}

		if (close == false) {
			goto end;
		}

		/* Everything is sent and aknowledged, do active close */
		P_TCP.send(ts_TCP(f := TH_FIN or4b TH_ACK, th_seq := u32_post_inc(seq),
						  th_ack := ack));
		st(TCP_FIN_WAIT1, fail_on := EV_TIMEOUT or4b EV_UNEXPECTED_MSG);

		/* TODO: peer_assert() here is tricky, since peer in active close
		   sends ack and fin+ack immedeately */
label wait_for_data;
		T.start; repeat;
	}
	[s == TCP_FIN_WAIT1] P_TCP.receive(tr_TCP(f := TH_ACK,
											  th_seq := ack, th_ack := seq)) {
		T.stop;
		/* TODO: peer_assert() here is tricky, since peer in active close
		   sends ack and fin+ack immedeately */
		st(TCP_FIN_WAIT2);
		T.start; repeat;
	}
	[s == TCP_FIN_WAIT2] P_TCP.receive(tr_TCP(f := TH_FIN or4b TH_ACK,
											  th_seq := ack, th_ack := seq)) {
		T.stop;
		peer_assert(TCP_LAST_ACK);
		P_TCP.send(ts_TCP(f := TH_ACK, th_seq := seq, th_ack := u32_pre_inc(ack)));
		st(TCP_TIME_WAIT, fail_on := EV_NONE);
		T.start; repeat; /* T * 2 */
	}
	[s == TCP_TIME_WAIT] T.timeout {
		st(TCP_CLOSED);
		peer_assert(TCP_CLOSED);
	}
	[] TT.timeout { setverdict(fail); stop; }
	}  /* end of alt */

	if (s == TCP_CLOSED and
			lengthof(data_to_send) == 0 and
			lengthof(snd) == 0 and
			data_received == data_to_receive) {
		setverdict(pass);
	} else {
		log("Error: data_to_receive=", data_to_receive, " ",
			"data_received=", data_received);
		setverdict(fail);
	}

	tp_send(TP_COMMAND, "CLOSE");
label end;
}

/**
 * Test peer's passive connection establishment, data transfer and close
 */
function tcp_listen(octetstring data_to_receive := ''O,
								boolean close := true,
								integer isn := 0) runs on tcp_ct
{
	var octetstring data := ''O; /* data received from the peer */

	tcp_init();

	TT.start;

	tp_send(TP_COMMAND, "CONNECT", d := oct2str(data_to_receive), isn := isn);

	st(TCP_LISTEN, fail_on := EV_TIMEOUT or4b EV_UNEXPECTED_MSG);
	T.start;

	alt {
	[s == TCP_LISTEN] P_TCP.receive(tr_TCP(f := TH_SYN)) -> value tcp {
		T.stop;
		peer_assert(TCP_SYN_SENT);
		st(TCP_SYN_RECEIVED);
		ack := tcp.th_seq;
		P_TCP.send(ts_TCP(f := TH_SYN or4b TH_ACK, th_seq := u32_post_inc(seq),
						  th_ack := u32_pre_inc(ack)));
		st(TCP_SYN_SENT);
		T.start; repeat;
	}
	[s == TCP_SYN_SENT] P_TCP.receive(tr_TCP(f := TH_ACK,
											 th_ack := seq)) -> value tcp {
		T.stop;
		st(TCP_SYN_RECEIVED);
		ack := tcp.th_seq;
		st(TCP_ESTABLISHED, fail_on := EV_NONE);
		if (close == false) {
			goto end;
		}
		T.start; repeat;
	}
	[s == TCP_ESTABLISHED] P_TCP.receive(tr_TCP(f := TH_PSH, th_seq := ack,
												d := ?)) -> value tcp {
		T.stop;
		peer_assert(TCP_ESTABLISHED);
		P_TCP.send(ts_TCP(f := TH_ACK, th_seq := seq,
						  th_ack := u32_pre_inc(ack, lengthof(tcp.data))));
		data_push(data, tcp.data);
		T.start; repeat;
	}
	[s == TCP_ESTABLISHED] T.timeout {
		peer_assert(TCP_ESTABLISHED);
		if (data == data_to_receive) {
			/* Everything is received, do active close */
			P_TCP.send(ts_TCP(f := TH_FIN or4b TH_ACK, th_seq := u32_post_inc(seq),
							  th_ack := ack));
			st(TCP_FIN_WAIT1, fail_on := EV_TIMEOUT or4b EV_UNEXPECTED_MSG);
		}
		T.start; repeat;
	}
	[s == TCP_FIN_WAIT1] P_TCP.receive(tr_TCP(f := TH_ACK,
											  th_seq := ack, th_ack := seq)) {
		T.stop;
		st(TCP_FIN_WAIT2);
		T.start; repeat;
	}
	[s == TCP_FIN_WAIT2] P_TCP.receive(tr_TCP(f := TH_FIN or4b TH_ACK,
											  th_seq := ack, th_ack := seq)) {
		T.stop;
		peer_assert(TCP_LAST_ACK);
		P_TCP.send(ts_TCP(f := TH_ACK, th_seq := seq, th_ack := u32_pre_inc(ack)));
		st(TCP_TIME_WAIT, fail_on := EV_NONE);
		T.start; repeat; /* TODO: T * 2 */
	}
	[s == TCP_TIME_WAIT] T.timeout {
		st(TCP_CLOSED);
		peer_assert(TCP_CLOSED);
	}
	[] TT.timeout { setverdict(fail); stop; }
	} /* end of alt */

	if (s == TCP_CLOSED and data_to_receive == data) {
		setverdict(pass);
	} else {
		log("Error: data_to_receive=", data_to_receive, " ",
			"data=", data);
		setverdict(fail);
	}

	tp_send(TP_COMMAND, "CLOSE");
label end;
}

testcase test_tcp_undersized() runs on tcp_ct
{
	tcp_init();

	var ip_t ip := valueof(ts_IP(IPPROTO_TCP, ''O));

	P_IP.send(ip);

	setverdict(pass); /* TODO: check peer's state */
}

/**
 * Test a reaction on SYN with incorrect th_off
 */
testcase test_tcp_incorrect_offset() runs on tcp_ct
{
	tcp_init();

	P_TCP2.send(ts_TCP2(fl := TH_SYN, seq := u32_post_inc(seq), off := 3));

	T.start;
	alt {
	[] P_TCP.receive(tr_TCP(f := TH_RST)) {
		T.stop;
		setverdict(pass);
	}
	[] T.timeout {
		setverdict(fail);
	}
	} /* end of alt */

	tp_send(TP_COMMAND, "CLOSE");
}

testcase test_tcp_no_flags() runs on tcp_ct
{
	tcp_init();

	P_TCP.send(ts_TCP(f := TH_NONE));

	setverdict(pass); /* TODO: check peer's state */
}

/**
 * Test active TCP connection establishment and active close
 */
testcase test_tcp_connect_no_data_close() runs on tcp_ct
{
	tcp_connect(data_to_send := ''O);
}

/**
 * Test that RST works in ESTABLISHED
 */
testcase test_tcp_connect_no_data_reset() runs on tcp_ct
{
	var udp_t udp;
	var tp_new_t tp;

	tcp_connect(close := false);

	tcp_config({{ "tp_trace", "1" }});

	P_TCP.send(ts_TCP(f := TH_RST, th_seq := seq));
	T.start;

	alt {
	[] P_UDP.receive(?) -> value udp {
		T.stop;
		tp := f_tp_new_dec(udp.data);
		if (tp.data[0].val == "CONN_DELETE") {
			setverdict(pass);
		}
	}
	[] T.timeout { setverdict(fail); }
	} /* end of alt */

	tp_send(TP_COMMAND, "CLOSE");
}

/**
 * Test peer's active TCP connection establishment,
 * data transfer (data echoing expected) and suite's active close
 */
testcase test_tcp_connect_data_close() runs on tcp_ct
{
	tcp_connect(data_to_send := '01'O, data_to_receive := '01'O);
}

/**
 * Test active TCP connection establishment,
 * "more data" data transfer (data echoing expected) and active close
 */
testcase test_tcp_connect_more_data_close() runs on tcp_ct
{
	tcp_connect(data_to_send := '010203'O, data_to_receive := '010203'O);
}

/**
 * Test that peer sends RST on missing data in ESTABLISHED
 */
testcase test_tcp_connect_data_gap() runs on tcp_ct
{
	var udp_t udp;
	var tp_new_t tp;
	var boolean reset_received := false;

	tcp_connect(close := false);

	tcp_config({{ "tp_trace", "1" }});

	P_TCP.send(ts_TCP(f := TH_PSH, th_seq := seq + 42, d := '01'O));
	T.start;

	alt {
	[] P_TCP.receive(tr_TCP(f := TH_RST)) {
		T.stop;
		reset_received := true;
		T.start; repeat;
	}
	[reset_received] P_UDP.receive(?) -> value udp {
		T.stop;
		tp := f_tp_new_dec(udp.data);
		if (tp.data[0].val == "CONN_DELETE") {
			setverdict(pass);
		}
	}
	[] T.timeout { setverdict(fail); }
	} /* end of alt */

	tp_send(TP_COMMAND, "CLOSE");
}

/**
 * Test passive TCP connection establishment and active close
 */
testcase test_tcp_listen_no_data_close() runs on tcp_ct
{
	tcp_listen(data_to_receive := ''O);
}

/**
 * Test that RST works in ESTABLISHED
 */
testcase test_tcp_listen_no_data_reset() runs on tcp_ct
{
	var udp_t udp;
	var tp_new_t tp;

	tcp_listen(close := false);

	tcp_config({{ "tp_trace", "1" }});

	P_TCP.send(ts_TCP(f := TH_RST, th_seq := seq));
	T.start;

	alt {
	[] P_UDP.receive(?) -> value udp {
		T.stop;
		tp := f_tp_new_dec(udp.data);
		if (tp.data[0].val == "CONN_DELETE") {
			setverdict(pass);
		}
	}
	[] T.timeout { setverdict(fail); }
	} /* end of alt */

	tp_send(TP_COMMAND, "CLOSE");
}

/**
 * Test passive TCP connection establishment, data and active close
 */
testcase test_tcp_listen_data_close() runs on tcp_ct
{
	tcp_listen(data_to_receive := '01'O);
}

/**
 * Test passive TCP connection establishment, data and active close
 */
testcase test_tcp_listen_more_data_close() runs on tcp_ct
{
	tcp_listen(data_to_receive := '010203'O);
}

/**
 * Test sequence wraps/overflows
 */
testcase test_tcp_connect_seq_wrap() runs on tcp_ct
{
	tcp_connect(data_to_send := '01'O, data_to_receive := '01'O,
					 isn := hex2int('FFFFFFFE'H));
}

testcase test_tcp_listen_seq_wrap() runs on tcp_ct
{
	tcp_listen(data_to_receive := '01'O, isn := hex2int('FFFFFFFE'H));
}

/**
 * Test peer's retransmission
 */
testcase test_tcp_retransmit() runs on tcp_ct
{
	tcp_init();

	fuzzer_on();

	P_FZ.send("incoming_drop");

	P_TCP.send(ts_TCP(f := TH_SYN, th_seq := post_inc(seq)));
	st(TCP_SYN_SENT);
	T.start(T_default * 3.0);
	T.timeout;
	P_FZ.send("incoming_pass");

	TT.start;
	T.start(T_default * 3.0);

	alt {
	[] P_TCP.receive(tr_TCP(f := TH_SYN or4b TH_ACK,
							th_ack := seq)) -> value tcp {
		T.stop;
		ack := tcp.th_seq;
		P_TCP.send(ts_TCP(f := TH_ACK, th_seq := seq, th_ack := pre_inc(ack)));
		setverdict(pass);
	}
	[] T.timeout {
		setverdict(fail);
	}
	}

	T.start(T_default);
	T.timeout;

	st(TCP_ESTABLISHED, fail_on := EV_NONE);

	tp_send(TP_COMMAND, "CLOSE");
}

type record of octetstring tcp_test_data_t;

/**
 * Test the reception of data with variable chunks, verify peer's seq and ack,
 * and check what the peer has received with the TP_COMMAND/RECV
 */
/* TODO: Enhance this one with out of order data */
testcase test_tcp_recv() runs on tcp_ct
{
	var tcp_test_data_t data := { '01'O, '0203'O, '040506'O };
	var octetstring data_total := ''O;

	tcp_connect(close := false);

	tcp_config({{ "tcp_echo", "0" }});

	for (var integer i := 0; i < sizeof(data); i := i + 1) {
		data_total := data_total & data[i];
		tcp_send(data[i]);
	}

	var tp_t peer := tp_send(TP_COMMAND, "RECV");

	if (str2oct(peer.data) == data_total) {
		setverdict(pass);
	}

	tp_send(TP_COMMAND, "CLOSE");
}

/**
 * Send an undersized data in ESTABLISHED
 */
testcase test_tcp_data_undersized() runs on tcp_ct
{
	tcp_connect(close := false);

	P_TCP.send(ts_TCP(f := TH_PSH, th_seq := seq, d := ''O));

	T.start;

	alt {
	[s == TCP_ESTABLISHED] P_TCP.receive(tr_TCP(f := TH_RST)) {
		T.stop;
		peer_assert(TCP_CLOSED);
		setverdict(pass);
	}
	[s == TCP_ESTABLISHED] T.timeout {
		setverdict(fail);
	}
	} /* end of alt */

	tp_send(TP_COMMAND, "CLOSE");
}

/**
 * Test a reaction on TCP data packets with options
 */
testcase test_tcp_data_options() runs on tcp_ct
{
	tcp_connect(close := false);

	var octetstring data_to_send := '010203'O;

	tcp := valueof(ts_TCP(f := TH_PSH,
						  th_seq := u32_post_inc(seq, lengthof(data_to_send)),
						  d := data_to_send));
	tcp.opt := {
		{ TO_MSS, 4, '0000'O }
	}

	P_TCP.send(tcp);
	T.start;

	alt {
	[s == TCP_ESTABLISHED] P_TCP.receive(tr_TCP(f := TH_ACK, th_ack := seq)) {
		T.stop;
		T.start; repeat;
	}
	[s == TCP_ESTABLISHED] P_TCP.receive(tr_TCP) -> value tcp {
		T.stop;
		if (th_is_set(tcp, TH_PSH) and tcp.data == data_to_send) {
			setverdict(pass);
			goto end;
		}
	}
	[s == TCP_ESTABLISHED] T.timeout {
		setverdict(fail);
		goto end;
	}
	} /* end of alt */

	peer_assert(TCP_ESTABLISHED);

label end;
	tp_send(TP_COMMAND, "CLOSE");
}

/**
 * Test a reaction on TCP data packets with incorrect options
 */
testcase test_tcp_data_incorrect_options() runs on tcp_ct
{
	tcp_connect(close := false);

	var octetstring data_to_send := '010203'O;

	tcp := valueof(ts_TCP(f := TH_PSH,
						  th_seq := u32_post_inc(seq, lengthof(data_to_send)),
						  d := data_to_send));
	tcp.opt := {
		{ TO_MSS, 3, '00'O } /* Incorrect option length */
	}

	P_TCP.send(tcp);
	T.start;

	alt {
	[s == TCP_ESTABLISHED] P_TCP.receive(tr_TCP(f := TH_RST)) {
		T.stop;
		setverdict(pass);
	}
	[s == TCP_ESTABLISHED] T.timeout {
		setverdict(fail);
		goto end;
	}
	} /* end of alt */

	peer_assert(TCP_CLOSED);

label end;
	tp_send(TP_COMMAND, "CLOSE");
}

/**
 * Test a reaction on TCP data with incorrect offset
 */
testcase test_tcp_data_incorrect_offset() runs on tcp_ct
{
	var octetstring data_to_send := '010203'O;

	tcp_connect(close := false);

	var tcp2_t tcp2 := valueof(ts_TCP2(fl := TH_PSH,
							seq := u32_post_inc(seq, lengthof(data_to_send)),
							off := 3,
							data := data_to_send));
	P_TCP2.send(tcp2);

	T.start;

	alt {
	[s == TCP_ESTABLISHED] P_TCP.receive(tr_TCP(f := TH_RST)) {
		T.stop;
		peer_assert(TCP_CLOSED);
		setverdict(pass);
	}
	[s == TCP_ESTABLISHED] T.timeout {
		setverdict(fail);
	}
	} /* end of alt */

	tp_send(TP_COMMAND, "CLOSE");
}

control {

	var integer i := number_of_runs, tests_failed := 0;

	while (post_dec(i) > 0) {
		execute(test_tcp_codecs());
		execute(test_tcp_undersized());
		execute(test_tcp_incorrect_offset());
		execute(test_tcp_no_flags());
		execute(test_tcp_connect_no_data_close());
		execute(test_tcp_connect_no_data_reset());
		execute(test_tcp_connect_data_close());
		execute(test_tcp_connect_more_data_close());
		execute(test_tcp_connect_data_gap());
		execute(test_tcp_listen_no_data_close());
		execute(test_tcp_listen_no_data_reset());
		execute(test_tcp_listen_data_close());
		execute(test_tcp_listen_more_data_close());
		execute(test_tcp_connect_seq_wrap());
		execute(test_tcp_listen_seq_wrap());
		execute(test_tcp_retransmit());
		execute(test_tcp_recv());
		execute(test_tcp_data_undersized());
		execute(test_tcp_data_options());
		execute(test_tcp_data_incorrect_options());
		execute(test_tcp_data_incorrect_offset());
	}

} /* end of control */

} /* end of module */
